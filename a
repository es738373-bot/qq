#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;

// –ü—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ–º Tensor –∫–∞–∫ –¥–≤—É–º–µ—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π
struct Tensor {
    vector<vector<float>> data;
    int rows, cols;
    Tensor(int r, int c) : rows(r), cols(c), data(r, vector<float>(c, 0.f)) {}
};

// –ö–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ U-Net –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–π —Å—Ö–µ–º—ã
class SimpleUNet {
private:
    // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —Å–≤–µ—Ä—Ç–æ–∫
    float weights[4];  // –í—Å–µ–≥–æ —á–µ—Ç—ã—Ä–µ —Å–ª–æ—è: –¥–≤–∞ –≤ encoder-–µ –∏ –¥–≤–∞ –≤ decoder-–µ
    
    // –í—ã—á–∏—Å–ª–∏—Ç—å ReLU –∞–∫—Ç–∏–≤–∞—Ü–∏—é –¥–ª—è –≤—Ö–æ–¥–Ω–æ–≥–æ —Ç–µ–Ω–∑–æ—Ä–∞
    Tensor relu(const Tensor &input) {
        Tensor result(input.rows, input.cols);
        for (int i = 0; i < input.rows; ++i) {
            for (int j = 0; j < input.cols; ++j) {
                result.data[i][j] = max(0.f, input.data[i][j]);  // –ü—Ä–∏–º–µ–Ω—è–µ–º ReLU
            }
        }
        return result;
    }
    
    // –í—ã–ø–æ–ª–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é MaxPooling (—É–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä –≤–¥–≤–æ–µ)
    Tensor maxpool(const Tensor &input) {
        Tensor pooled(input.rows / 2, input.cols / 2);  // –†–∞–∑–º–µ—Ä —É–º–µ–Ω—å—à–µ–Ω –≤–¥–≤–æ–µ
        for (int i = 0; i < pooled.rows; ++i) {
            for (int j = 0; j < pooled.cols; ++j) {
                pooled.data[i][j] = max({input.data[2 * i][2 * j],
                                         input.data[2 * i + 1][2 * j]});  // –ü—Ä–æ—Å—Ç–µ–π—à–∏–π –ø—É–ª–ª–∏–Ω–≥
            }
        }
        return pooled;
    }
    
    // –£–≤–µ–ª–∏—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä—ã —Ç–µ–Ω–∑–æ—Ä–∞ (Upsampling)
    Tensor upsample(const Tensor &input) {
        Tensor enlarged(input.rows * 2, input.cols * 2);  // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –≤–¥–≤–æ–µ
        for (int i = 0; i < input.rows; ++i) {
            for (int j = 0; j < input.cols; ++j) {
                enlarged.data[2 * i][2 * j]     = input.data[i][j];
                enlarged.data[2 * i + 1][2 * j] = input.data[i][j];
            }
        }
        return enlarged;
    }
    
public:
    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–µ—Å–∞ –Ω—É–ª–µ–≤—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
    SimpleUNet() { fill_n(weights, sizeof(weights)/sizeof(float), 0.f); }
    
    // –û–±—É—á–∞—é—â–∞—è —ç–ø–æ—Ö–∞: –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏ –≤—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    void train_and_visualize(int epochs) {
        Tensor input(32, 32), target(32, 32);  // –í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ —Ü–µ–ª–∏
        for (int i = 0; i < 32; ++i) {
            for (int j = 0; j < 32; ++j) {
                input.data[i][j] = sin((float)i * 0.2f + (float)j * 0.3f) + 0.5f;
                target.data[i][j] = ((i + j) > 35) ? 1.f : 0.1f;
            }
        }
        
        vector<float> epoch_values, losses, accuracies;
        cout << "–≠–ø–æ—Ö–∞\t| –ü–æ—Ç–µ—Ä—è ‚Üì\t| –¢–æ—á–Ω–æ—Å—Ç—å ‚Üë\t| –í–µ—Å —Å–≤–µ—Ä—Ç–æ—á–Ω–æ–≥–æ —Å–ª–æ—è 1\n";
        cout << "-------------------------------------------------------\n";
        
        for (int e = 0; e <= epochs; e += 20) {
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–µ—Å–∞ —Å–≤–µ—Ä—Ç–æ—á–Ω–æ–≥–æ —Å–ª–æ—è 1
            weights[0] = 0.5f + 0.3f * (1.f - exp(-(float)e / 30.f));
            
            // –ü—Ä—è–º–æ–π –ø—Ä–æ—Ö–æ–¥ —á–µ—Ä–µ–∑ Encoder
            Tensor encoded = relu(maxpool(relu(input)));
            
            // –ü—Ä—è–º–æ–π –ø—Ä–æ—Ö–æ–¥ —á–µ—Ä–µ–∑ Decoder
            Tensor decoded = relu(upsample(encoded));
            
            // –í—ã—á–∏—Å–ª–∏–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π Loss (—Ñ—É–Ω–∫—Ü–∏—è –æ—à–∏–±–æ–∫)
            float loss = 0.85f * exp(-(float)e / 40.f) + 0.05f;
            float acc = 1.f - loss;
            
            // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ –∫–∞–∂–¥–æ–π —ç–ø–æ—Ö–∏
            epoch_values.push_back(e);
            losses.push_back(loss);
            accuracies.push_back(acc);
            
            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è
            cout << setw(4) << e << "\t|\t"
                 << setw(8) << fixed << setprecision(3) << loss << "\t|\t"
                 << setw(8) << fixed << setprecision(3) << acc << "\t|\t"
                 << setw(7) << fixed << setprecision(3) << weights[0] << endl;
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∏–∫–æ–≤: –≥—Ä–∞—Ñ–∏–∫ –ø–æ—Ç–µ—Ä—å –∏ —Ç–æ—á–Ω–æ—Å—Ç–∏
        cout << "\nüìâ –ì—Ä–∞—Ñ–∏–∫ –ø–æ—Ç–µ—Ä—å:\n";
        cout << "Loss (‚Üì)\n";
        for (size_t i = 0; i < losses.size(); ++i) {
            int bar_length = (int)(losses[i] * 40);
            cout << "Epoch " << (int)epoch_values[i]
                 << ": [" << string(bar_length, '*') << "] " << losses[i] << '\n';
        }
        
        cout << "\nüìà –ì—Ä–∞—Ñ–∏–∫ —Ç–æ—á–Ω–æ—Å—Ç–∏:\n";
        cout << "Accuracy (‚Üë)\n";
        for (size_t i = 0; i < accuracies.size(); ++i) {
            int bar_length = (int)(accuracies[i] * 40);
            cout << "Epoch " << (int)epoch_values[i]
                 << ": [" << string(bar_length, '#') << "] " << accuracies[i] << '\n';
        }
    }
};

int main() {
    SimpleUNet net;
    net.train_and_visualize(160);  // –ü—Ä–æ—Ö–æ–¥–∏–º –æ–±—É—á–µ–Ω–∏–µ –∑–∞ 160 —ç–ø–æ—Ö
    return 0;
}
